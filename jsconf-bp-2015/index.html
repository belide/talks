<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>C++ internals of io.js</title>

    <meta name="description" content="Diving into C++ internals of io.js">
    <meta name="author" content="Fedor Indutny">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
    <link rel="stylesheet" href="css/main.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Diving into C++ internals of <b>io.js</b></h1>
          <p>
            <small>by <a href="https://github.com/indutny">Fedor Indutny</a> / <a href="http://twitter.com/indutny">@indutny</a></small>
          </p>
        </section>

        <section>
          <h2>whoami</h2>
          <h3>Fedor Indutny</h3>
          <p class="fragment">io.js TC member and...</p>
          <p class="fragment"><small>(node.js core team member)</small></p>
        </section>

        <section>
          <img height="500" data-src="images/jsconf-bp-qr.svg" />
          <p>
            <small>
              <a href="http://jsconfbp.indutny.com/">
                http://jsconfbp.indutny.com
              </a>
            </small>
          </p>
        </section>

        <section>
          <h1>Diving into C++ internals of <b>io.js</b></h1>
        </section>

        <section>
          <section>
            <h2>Alternative title</h2>
          </section>
          <section>
            <img height="640" data-src="images/history_of_git_blame.jpg" />
          </section>
          <section>
            <h1>A History Of GIT BLAME</h1>
          </section>
        </section>

        <section>
          <section>
            <h2>C++ talk on</h2>
            <h2>JS conference</h2>

            <aside class="notes">
              It might seem crazy to speak about C++ on a JavaScript conference.
            </aside>
          </section>
          <section>
            <h2>Like anyone cares...</h2>
          </section>
          <section>
            <h2>...or write in C++ a lot</h2>
          </section>
          <section>
            <h1>...in fact</h1>
            <h1>you wrote</h1>
            <h1>C++ code</h1>

            <aside class="notes">
              ...but if you ever tried to optimize JavaScript code to squeeze
              every possible performance or memory usage improvement out of it -
              you already wrote some C++ code.
            </aside>
          </section>

        </section>

        <section>
          <section>
            <h2>Ways to optimize JS</h2>

            <aside class="notes">
              <p>
                Many blog posts, workshops are devoted to JavaScript
                optimizations, and some of the popular suggestions are
              </p>
            </aside>
          </section>

          <section>
            <h2>Avoid "hidden classes"</h2>
            <pre><code class="javascript" data-trim contenteditable>
function Point(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
}
            </code></pre>
            <small>This is JS ^</small>

            <aside class="notes">
              Declare all properties in the constructor to avoid "hidden
              classes".
            </aside>
          </section>

          <section>
            <h2>Compare to:</h2>
            <pre><code class="c" data-trim contenteditable>
class Point {
 public:
  double x;
  double y;
  double z;
};
            </code></pre>
            <small>This is C++ ^</small>

            <aside class="notes">
              Which makes them pretty much the same as a C structures,
              or C++ classes. Stuff should be declared ahead of time to help
              the compiler optimize it.
            </aside>
          </section>

          <section>
            <h2>Avoid "polymorphism"</h2>

            <pre><code class="javascript" data-trim contenteditable>
function add(x, y) {
  return x + y;
}

add(0, 1); // <- good
add('foo', 'bar'); // <- polymorphism!
            </code></pre>

            <aside class="notes">
              Avoid storing different types of values in a variables, and
              avoid passing different types as the same argument to the
              function. This principle could also be called "Make your code
              monomorphic", or do not mess with the compiler, and this is
              pretty much the same as a static typing in C/C++.
            </aside>
          </section>

          <section>
            <h2>Manual allocation</h2>

            <pre><code class="javascript" data-trim contenteditable>
function Parser() {
}

Parser.freelist = [];

Parser.get = function() {
  if (this.freelist.length)
    return this.freelist.pop();
  return new Parser();
};

Parser.prototype.release = ...;
            </code></pre>

            <aside class="notes">
              Cache and reuse instances and objects that are often
              allocated to avoid GC pauses. This is one is sort of a manual
              memory allocation.
            </aside>
          </section>

          <section>
            <h1>Fast JS</h1>
            <h1>==</h1>
            <h1>C++</h1>

            <aside class="notes">
              To conclude, even if you never wrote C++ code, you actually very
              likely did it in JS.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>(io|node).js</h1>
            <h2>use C/C++</h2>
            <h3 class="fragment">internally</h3>
            <small class="fragment">if you didn't know about it</small>

            <aside class="notes">
              No surprise we use C++ in io.js/node.js.
            </aside>
          </section>

          <section>
            <h2>V8 is in C++</h2>

            <br/>

            <h3 class="fragment">also</h3>
            <h3 class="fragment">has only ECMA API</h3>

            <aside class="notes">
              V8 is written in C++ after all and it is only providing a limited,
              mostly ECMAScript-only JavaScript APIs.
            </aside>
          </section>

          <section>
            <h3>Which is cool</h3>
            <h3>Unless you need timers</h3>
            <h3 class="fragment">...or File System API</h3>
            <h3 class="fragment">...or Networking</h3>

            <aside class="notes">
              They are definitely cool, but if you ever used `setTimeout()`/
              `clearTimeout()` - you won't have them in plain ECMAScript. At
              least not yet.
            </aside>
          </section>

          <section>
            <p>Node.js C++ layer:</p>
            <p class="fragment">Lives on top of the event-loop</p>
            <p class="fragment">Provides</p>
            <ul>
              <li class="fragment">net sockets</li>
              <li class="fragment">dns queries</li>
              <li class="fragment">file system</li>
              <li class="fragment">zlib bindings</li>
              <li class="fragment">other stuff...</li>
            </ul>

            <aside class="notes">
              Our C++ layer lives on top of the event-loop and provides all
              sorts of APIs: from net sockets to dns queries, from file system
              events to the zlib bindings.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h3>Back to the</h3>
            <h3>alternative title</h3>
          </section>

          <section>
            <h1>A History Of GIT BLAME</h1>
          </section>

          <section>
            <p>Start with history of the subject</p>
            <p>to ease the understanding of</p>
            <p>C++ layer</p>

            <aside class="notes">
              To better understand all of these, and to ease the contribution
              process - it might be a good idea to start with the history of the
              subject.
            </aside>
          </section>

          <section>
            <p>Node.js uses git since beginning</p>
            </br>
            <p class="fragment">The history is in</p>
            <p class="fragment">
              <b class="fragment">git log</b>
              <i> &amp; </i>
              <b class="fragment">git blame</b>
            </p>

            <aside class="notes">
              Luckily, from its inception, node.js is using VCS, in particular
              git, so the history of the  development might be revealed by
              running `git log` and `git blame` on it.
            </aside>
          </section>

          <section>
            <p>
            <b>`git log deps/v8`</b> - v8 fighting us
            </p>
            <p class="fragment">
              <b>`git log src/`</b> - us fighting v8
            </p>

            <aside class="notes">
              Briefly, `git log deps/v8` - has the history of v8 fighting us,
              and `git log src/` - has the history of us fighting v8.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <img height="640" data-src="images/nodejs_begins.jpg" />
          </section>

          <section>
            <h1>node.js begins</h1>
          </section>

          <section>
            <h3>61890720 commit</h3>

            <aside class="notes">
              Jokes aside, everything started from 61890720 commit. The commit
              log just says:
            </aside>
          </section>

          <section>
            <h3>Commit log:</h3>
            <p>&#8220;add readme and initial code&#8221;</p>
            <br/>
            <b class="fragment">git checkout 61890720</b>

            <aside class="notes">
              Unfortunately, we can't elaborate much from it, and need to figure
              out the details ourselves. What do we see there?
            </aside>
          </section>

          <section>
            <p>Two C/C++ dependencies except V8:</p>
            <ul>
              <li class="fragment"><b>libebb</b> - for HTTP</li>
              <li class="fragment"><b>liboi</b> - for TCP/libev</li>
            </ul>

            <aside class="notes">
              libebb - which was used as an HTTP parser. Ryan used the code
              from the Ebb server that he has previously written for Ruby
              <br/>
              liboi- which was as a TCP server framework on top of the libev.
              liboi stands for `Library for Output Input`
            </aside>
          </section>

          <section>
            <p>./server script.js</p>
            <pre><code class="javascript" data-trim contenteditable>
function Process(request) {
  if (options.verbose) {
    log("Processing " + request.host +
        request.path +
        " from " + request.referrer +
        "@" + request.userAgent);
  }
  if (!output[request.host])
    output[request.host] = 1;
  else
    output[request.host]++
}
            </code></pre>

            <aside class="notes">
              So the first code (that actually started compiling only at
              7b7ceea) only had one HTTP server and supplied JavaScript source
              code was just a handler for it.
            </aside>
          </section>

          <section>
            <h4>How was it organized internally?</h4>

            <ul>
              <li class="fragment">
                <b>server.cc</b> - command-line args, load JS
              </li>
              <li class="fragment">
                <b>js_http_request_processor.cc</b> - http request handler
              </li>
            </ul>

            <aside class="notes">
              <p>There was a `server.cc` file which was reading the command line
              options, loading the JS source file, feeding all of these into V8,
              and starting the HTTP server.</p>

              <p>Second C++ file was `js_http_request_processor.cc` and it was
              responsible for invoking JavaScript http request handler. Kind of
              overshoot, right?</p>
            </aside>
          </section>

          <section>
            <h2>Almost nothing working</h2>
            <h3>at that point</h3>

            <p class="fragment">(Just a Proof-of-Concept)</p>

            <aside class="notes">
              It wasn't working that much at that point, and didn't have any of
              functionality that is provided today. So let's conclude and move
              on from it quickly:
            </aside>
          </section>

          <section>
            <h2>Summary:</h2>
            <ul>
              <li class="fragment">one file to setup V8 and CLI args</li>
              <li class="fragment">
                HTTP server is in C/C++, without any networking events
              </li>
              <li class="fragment">
                One C++ instance for every request
                <p class="fragment">
                  <small>(Mapping uri, headers, method to JS object)</small>
                </p>
              </li>
            </ul>

            <aside class="notes">
              <ul>
                <li>
                  One file to setup V8 and let JavaScript know about
                  command-line arguments
                </li>
                <li>
                  HTTP server fully implemented in C/C++, not invoking
                  JavaScript for any networking activities
                </li>
                <li>
                  One C++ instance per every incoming request. This instance
                  maps some of the HTTP fields (like host, url, method) to the
                  JavaScript object.
                </li>
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <p>Quickly jumping to</p>
            <p>064c8f02 commit</p>

            <aside class="notes">
              Now we quickly jump to 064c8f02.
            </aside>
          </section>

          <section>
            <h2>Commit log:</h2>
            <p>
              &#8220;Use ObjectWrap base class for File, Socket, Server.&#8221;
            </p>
          </section>

          <section>
            <p>One API to wrap all objects</p>

            <pre><code class="c" data-trim contenteditable>
class File : public ObjectWrap {
 public:
  File(Handle&lt;Object&gt; handle)
      : ObjectWrap(handle) {
  }
};
            </code></pre>

            <aside class="notes">
              At first node.js had only one C++ instance that was mapped to JS
              object, but at this point there are many of them, and node.js has
              introduced one API to wrap all objects and map their properties.
            </aside>
          </section>

          <section>
            <ul>
              <li><b>net.Server</b></li>
              <li class="fragment"><b>net.Socket</b></li>
              <li class="fragment"><b>File</b></li>
            </ul>

            <p class="fragment">are <b>ObjectWrap</b> instances</p>

            <aside class="notes">
              Now `net.Server`, `net.Socket`, `File` C++ classes are children of
              this `ObjectWrap` class. Which technically means that for every
              instance of them - there will be one instance of JS object that
              allows invoking C++ methods of these classes, and reading
              properties of this object in C++ (even invoking the callbacks!)
            </aside>
          </section>

          <section>
            <h4>File structure:</h4>
            <ul>
              <li class="fragment">
                <b>src/node.cc</b> - init C++ libs, invoke <b>src/main.js</b>
              </li>
              <li class="fragment">
                <b>src/http.cc</b> - HTTP server API, Connection, HttpRequest
              </li>
              <li class="fragment">
                <b>src/file.cc</b>, <b>src/file.js</b> - future FS module
              </li>
              <li class="fragment">
                <b>src/process.cc</b> - <b>.exit()</b>, future
                <b>process</b> object
              </li>
              <li class="fragment">
                <b>src/timers.cc</b> - <b>setTimeout</b>/<b>setInterval</b>
              </li>
            </ul>

            <aside class="notes">
              There are now different files for different parts of the provided
              API:

              <ul>
                <li>
                  `src/node.cc` now sets up C++ libraries and invokes
                  `src/main.js` which is loading script file and does some
                  JavaScript initialization. This is what is done now too. We
                  put as much as possible of the API into js module, and leave
                  the rest in the C++ land.
                </li>
                <li>
                  `src/http.cc` provides http server API, Connection,
                  HttpRequest objects
                </li>
                <li>
                  `src/file.cc`, `src/file.js` are basically something that grew
                  up into `fs` module. `src/file.js` consists of the API
                  abstractions for the C++ layer, basically the same thing as
                  with `src/node.cc` and `src/main.js`
                </li>
                <li>
                  `src/process.cc` provides `exit` method. Will grow up into
                  `process` object
                </li>
                <li>`src/timers.cc` is about `setTimeout`/`setInterval`</li>
              </ul>
            </aside>
          </section>

          <section>
            <h3><i>Side note:</i></h3>

            <p>
              HTTP server still provided by <b>liboi</b>, node.js is using libev
            </p>
          </section>
        </section>

        <section>
          <section>
            <h1>version 0.2</h1>
          </section>

          <section>
            <p>grown</p>
            <p class="fragment">
              matured <i class="fragment">(a bit)</i>
            </p>
            <p class="fragment"><b>Separating JS from C++</b></p>
            <p class="fragment">CommonJS</p>
            <p class="fragment">tons of core modules</p>

            <aside class="notes">
              There was lots of growing and maturing from that commit to the
              v0.2, and most notable of them were about separating the JS parts
              from the C++ ones, adding CommonJS support, and tons of modules!
            </aside>
          </section>

          <section>
            <h3>File structure:</h3>

            <ul>
              <li class="fragment">
                <b>lib/</b> - all JavaScript core modules
              </li>
              <li class="fragment">
                <b>src/</b> - their C++ counterparts
              </li>
              <li class="fragment">
                <b>deps/</b> - all C/C++ dependencies<br/>
                <i>(v8, http-parser, c-ares, libeio, libev)</i>
              </li>

            <aside class="notes">
              At this point node.js file structure starts looking like what we
              have now:

              <ul>
                <li>`lib/` folder for all JavaScript CommonJS modules</li>
                <li>`src/` for their C++ counterparts</li>
                <li>
                  `deps/` for all dependencies: v8, http-parser, c-ares (for
                  async DNS),
                </li>
                <li>
                  libeio (for async FS), and libev (for async networking and
                  auxiliary stuff)
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <p><b>ObjectWrap</b> is a public API now</p>

            <p class="fragment">(polished out for and by community)</p>

            <aside class="notes">
              Previously barely used through the `src/`, `ObjectWrap` now became
              a public API, which helped polish it out a lot and improved our
              core use case as well.
            </aside>
          </section>

          <section>
            <p>Previously all C++ classes were</p>
            <p><b>global objects</b></p>
            <p class="fragment">
              In v0.2 they are provided by <b>process.binding()</b>
            </p>

            <aside class="notes">
              Very importantly, in 064c8f02 all C++ interfaces were global
              objects. In v0.2 they are provided by `process.binding` and are
              thus not directly visible to the user's code.
            </aside>
          </section>

          <section>
            <h4>Example</h4>

            <pre><code class="javascript" data-trim contenteditable>
> process.binding('fs');
{ access: [Function: access],
  close: [Function: close],
  open: [Function: open],
  ...lots of stuff...
            </code></pre>

            <p class="fragment">...and similar stuff for other modules too</p>

            <aside class="notes">
              For example, `process.binding('fs')` returns lots of C++ methods
              and classes that are heavily used for interoperation between C++
              and JS in `lib/fs.js`. Similar stuff is done for the rest of the
              `lib/` modules.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>version 0.6</h1>
            <img class="fragment"
                 id="img-libuv"
                 height="240"
                 data-src="images/libuv.png" />
          </section>

          <section>
            <h3>Short note</h3>
            <ul>
              <li>
                <b>libev</b>/<b>libeio</b> was replaced by <b>libuv</b><br/>
                <small>
                  (Lots of work by Ben Noordhuis, Bert Belder, Ryan Dahl, and
                  others)
                </small>
              </li>
              <li class="fragment">Windows support</li>
            </ul>

            <aside class="notes">
              Just a short note: `libev` was removed and replaced by `libuv`.
              Lots of awesome work by Ben Noordhuis, Bert Belder, Ryan Dahl, and
              others! A major milestone in evolution of node.js. Windows is now
              in the list of the officially supported platforms.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>version 0.10</h1>
          </section>

          <section>
            <h1>boring</h1>
          </section>
        </section>

        <section>
          <section>
            <h1>version 0.12</h1>
            <h1>io.js</h1>
          </section>

          <section>
            <p>Lots of new stuff!</p>
            <small class="fragment">(We are interested only in C++)</small>
          </section>

          <section>
            <h3>Important thing:</h3>
            <p class="fragment">
              Outgrown <b>ObjectWrap</b>
              <br/>
              <i>(src/node_object_wrap.h)</i>
            </p>
            <p class="fragment">
              Now using <b>AsyncWrap</b>
              <br/>
              <i>(src/async-wrap.h)</i>
              <br/>
              <small>(two fields: parent and providerType)</small>
            </p>

            <aside class="notes">
              Mainly, we have outgrown the `ObjectWrap` to accommodate the
              tracing API (which is still needs lots of rework, AFAIK). Now the
              hip thing is `AsyncWrap` which is in many ways the same thing, but
              now is attached to some particular domain of operation (i.e. http,
              dns, tls) and which might have the another `AsyncWrap` as a
              parent. Note that `ObjectWrap` lives in `src/node_object_wrap.h`,
              and `AsyncWrap` in `src/async-wrap.h`.
            </aside>
          </section>
        </section>

        <section>
          <h3>We have arrived</h3>
          <h3>at the present point</h3>
          <h3>of node.js/io.js</h3>
        </section>

        <section>
          <h3>Time to stop the</h3>
          <h3>Software Archeology</h3>

          <aside class="notes">
            This is a present point of the node.js evolution, and like to stop
            with the Software Archeology at this point.
          </aside>
        </section>

        <section>
          <h3>Time to get into the</h3>
          <h3>C++ internals...</h3>
        </section>

        <section>
          <section>
            <h2>Interoperation</h2>
            <h2 class="fragment">Handles</h2>
            <h2 class="fragment">Wraps</h2>
            <h2 class="fragment animate-unicorns">Unicorns</h2>

            <aside class="notes">
              Now we are finally ready to dive into the C++ internals, and
              explore it.
            </aside>
          </section>

          <section>
            <h3>Two Folders - Two Worlds</h3>
            <b class="fragment">lib</b> - <b class="fragment">src</b>

            <aside class="notes">
              As we already figured out - whole APIs provided by the
              node.js/io.js do live in two folders: `lib` and `src`. `lib` holds
              the core modules, `src` holds their C++ counterparts.
            </aside>
          </section>

          <section>
            <p>
              <b>require('fs')</b>
            </p>

            <p class="fragment">
              Just loads <b>lib/fs.js</b> and executes it.
            </p>

            <h2 class="fragment">no magic</h2>

            <aside class="notes">
              For example, when you do `require('fs')` - it is doing nothing but
              just executing the contents of the `lib/fs.js` file. No magic
              here.
            </aside>
          </section>

          <section>
            <p>
              JS is not capable of FS operations.
            </p>
            <p class="fragment">
              No networking either.
            </p>
            <h2 class="fragment">it is for the best!</h2>

            <aside class="notes">
              Now comes the interesting thing, JS is not capable of the file
              system operations, nor it is capable of doing networking. At it is
              actually for the best! (You don't want your browser to mess up
              with the whole file system, right?)
            </aside>
          </section>

          <section>
            <h3>Because of</h3>
            <h2>Sandboxing</h2>
          </section>

          <section>
            <p>But... I need:</p>

            <p class="fragment">
              <b>fs.writeFileSync()</b>
            </p>
            <p class="fragment">
              <b>http.request()</b>
            </p>
            <p class="fragment">
              Lots of low-level C++ stuff outside of the JS-land
            </p>

            <aside class="notes">
              So when you do `fs.writeFileSync`, or when you are calling
              `http.request()` there are lots of low-level C++ stuff happening
              outside of the JS-land.
            </aside>
          </section>

          <section>
            <p>Let's learn by example</p>

            <p class="fragment">Though, <b>require('fs')</b> is boring</p>
            <p class="fragment">let's move to</p>

            <aside class="notes">
              While the `fs` module is quite simple to explain, it is quite
              boring too. After all, in the most of the cases it is just using
              number to represent the opened file (so called,
              `file descriptor`), and is just passing this number around:
              from C++ to JS, and from JS to C++. Nothing interesting, let's
              move on!
            </aside>
          </section>

          <section>
            <p><b>require('net')</b></p>

            <ul>
              <li class="fragment">creates sockets</li>
              <li class="fragment"><b>`connect`</b> events</li>
              <li class="fragment"><b>`.write()`</b> callbacks</li>
            </ul>

            <p class="fragment">All powered by C++ machinery!</p>

            <aside class="notes">
              Certainly much more interesting is the `net` module. We create
              sockets, get the `connect` events, and expect the `.write()`
              callbacks to be eventually invoked. All of these should be powered
              by the C++ machinery!
            </aside>
          </section>

          <section>
            <p>Provided by bindings:</p>
            <small><i>process.binding()</i></small>

            <ul>
              <li class="fragment">
                <b>tcp_wrap</b> - <i>(src/tcp_wrap.cc)</i>
              </li>
              <li class="fragment">
                <b>stream_wrap</b> - <i>(src/stream_wrap.cc)</i>
              </li>
            </ul>

            <aside class="notes">
              And here is where most of the interoperation is actually
              happening. The `tcp_wrap` and `stream_wrap` bindings (remember, =
              `process.binding()`, right?)
            </aside>
          </section>

          <section>
            <p>Bindings provide JS classes:</p>

            <ul>
              <li class="fragment">TCP</li>
              <li class="fragment">TCPConnectWrap</li>
              <li class="fragment">WriteWrap</li>
              <li class="fragment">ShutdownWrap</li>
            </ul>

            <aside class="notes">
              ...provide very useful classes for JS-land: TCP, TCPConnectWrap,
              WriteWrap, ShutdownWrap.
            </aside>
          </section>

          <section>
            <p>Purpose of these classes:</p>

            <ul>
              <li class="fragment">
                <b>TCP</b> - holds TCP socket, read/write
              </li>

              <li class="fragment">
                <b>*Wrap</b> - is what you pass in for async actions on TCP
              </li>
            </ul>

            <aside class="notes">
              Where `TCP` holds the TCP socket and provides methods for writing
              and reading stuff, and `*Wrap` objects is what you pass to the
              `TCP` methods when you expect some async action to happen, and
              need to receive notification (callback) on its completion.
            </aside>
          </section>

          <section>
            <h4>Example</h4>

            <p>`net.connect()` workflow:</p>

            <ol>
              <li class="fragment"><b>tcp = new TCP()</b></li>
              <li class="fragment">Store <b>tcp</b> in <b>_handle</b></li>
              <li class="fragment">Parse args to <b>net.connect</b></li>
              <li class="fragment"><b>req = new TCPConnectWrap()</b></li>
              <li class="fragment"><b>tcp.connect(req, port, host)</b></li>
              <li class="fragment">async <b>req.oncomplete()</b></li>
            </ol>

            <aside class="notes">
              <p>
                For example, the normal workflow for `net.connect()` follows:
              </p>

              <ul>
                <li>
                  Create `TCP` instance in `lib/net.js`, store it in the
                  `_handle` property of the `net.Socket` object
                </li>
                <li>Parse all arguments to the `net.connect()`</li>
                <li>Create `TCPConnectWrap` instance (usually named `req`)</li>
                <li>Invoke `.connect()` method with `req, port, host`</li>
                <li>
                  Get `req.oncomplete` function invoked eventually, once the
                  connection was established, or once the kernel will report a
                  error
                </li>
              </ul>
            </aside>
          </section>

          <section>
            <h3>Conslusion</h3>

            <p>C++ classes are either:</p>

            <ul>
              <li class="fragment">
                <b>Handle</b>
                <br/>
                <i>(not to be confused with v8 handles)</i>
              </li>

              <li class="fragment">
                <b>Wrap</b>
                <br/>
                <i>(async request wrap)</i>
                <br/>
                <i class="fragment">(lifetime &lt;= handle's)</i>
              </li>
            </ul>

            <aside class="notes">
              In conclusion: most of the C++ classes are either handles, or
              requests. Requests are very temporary and never outlive the handle
              that they are bound to, while the handles is something that lives
              much longer (i.e. for the entire life time of the TCP connection).
            </aside>
          </section>

          <section>
            <h3>File structure</h3>

            <ul>
              <li class="fragment">
                <b>src/tcp_wrap.cc</b>
                <ul>
                  <li><b>TCPWrap</b> (<b>TCP</b> in JS)</li>
                  <li class="fragment"><b>TCPConnectWrap</b></li>
                </ul>
              </li>
              <li class="fragment">
                <b>src/stream_base.cc</b> <i>(io.js only)</i>
                <ul>
                  <li class="fragment"><b>WriteWrap</b></li>
                  <li class="fragment"><b>ShutdownWrap</b></li>
                </ul>
              </li>
            </ul>

            <aside class="notes">
              Speaking of the file structure: `TCP` is represented by the
              `TCPWrap` class in `src/tcp_wrap.cc`, `TCPConnectWrap` lives in
              the same place, and `WriteWrap` is in the `stream_base.cc` file
              (in io.js).
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h3>Structure of C++ side</h3>
          </section>

          <section>
            <p>How does <b>process.binding()</b> work?</p>

            <aside class="notes">
              But how does the C++ provide this classes to the JavaScript?
            </aside>
          </section>

          <section>
            <pre><code class="c" data-trim contenteditable>
NODE_MODULE_CONTEXT_AWARE_BUILTIN(
    fs,
    node::InitFs)
            </code></pre>

            <p class="fragment">
              Has <span class="fragment">kind of</span> same effect as:
            </p>

            <pre class="fragment"><code class="javascript" data-trim>
cppModules['fs'] = {
  initialized: false,
  initFn: InitFS
};
            </code></pre>

            <aside class="notes">
              Each binding has `NODE_MODULE_CONTEXT_AWARE_BUILTIN` macro that
              registers it in the `node.cc`. This has the same effect as
              following JavaScript snippet.
            </aside>
          </section>

          <section>
            <p>So what <b>process.binding()</b> does?</p>

            <pre class="fragment"><code class="javascript" data-trim>
process.binding = function(moduleName) {
  var module = cppModules[moduleName];
  if (module.initialized)
    return module.exports;

  module.exports = {};
  module.initFn(module.exports);
  return module.exports;
};
            </code></pre>

            <aside class="notes">
              When `process.binding('moduleName')` is invoked, `node.cc` looks
              up the proper internal binding in this hashmap and initializes it
              (if it wasn't previously initialized) by calling the supplied
              function.
            </aside>
          </section>

          <section>
            <p>What <b>initFn</b> does?</p>

            <p class="fragment">Initializes module, like in CommonJS</p>

            <p class="fragment"><small>Thanks, captain!</small></p>

            <p class="fragment">Exports functions and classes</p>

            <aside class="notes">
              This initialization function receives `exports` object as an
              input, and exports the methods and classes to it in a pretty much
              the same way as you normally do in a CommonJS modules.
            </aside>
          </section>

          <section>
            <p>Each exported JS class has</p>
            <p>C++ <b>counterpart</b></p>

            <p class="fragment">Most of them inherit from <b>AsyncWrap</b></p>

            <aside class="notes">
              Each of the exported classes has a the C++ class, and most of them
              are actually a `AsyncWrap` C++ class children.
            </aside>
          </section>

          <section>
            <p>Small reminder. Two kinds of classes:</p>

            <p><b>Handle</b> and <b>Wrap</b></p>
          </section>

          <section>
            <p>Garbage Collector destroys only:</p>

            <p><b>Handle</b>s</p>

            <p class="fragment">
              Requests are manually destroyed
              <br/>
              after async action completion
              <br/>
              <i>(i.o.w. after callback)</i>
            </p>

            <aside class="notes">
              The Handle instances are destroyed automatically by V8's GC, and
              the Wraps are manually destroyed by the Handle, once they are not
              used anymore.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h1>Exam time</h1>
          </section>

          <section data-background="images/john-rambo.jpg">
            <h3>Time to test your skills!</h3>
          </section>

          <section>
            <h4>Situation:</h4>
            <p>You debug io.js issue, and find out that it</p>
            <p>is crashing on:</p>
            <pre><code class="javascript" data-trim contenteditable>
var FooBar = process.binding('foo_bar').FooBar;

// Crashes here:
var f = new FooBar();
            </code></pre>

            <p><b>Where will you search for FooBar</b>?</p>

            <aside class="notes">
              Situation: you debug some io.js/node.js issue, and find that it is
              crashing when instantiating a class provided by
              `process.binding('foo_bar')`. Where will you
              attempt to search the C++ source code of that class?
            </aside>
          </section>

          <section>
            <h4>Answer:</h4>

            <p>Somewhere in <b>src/</b>, searching by:</p>
            <pre><code class="c" data-trim contenteditable>
NODE_MODULE_CONTEXT_AWARE_BUILTIN(foo_bar, ..)
            </code></pre>

            <p class="fragment">
              This will be most likely in <b>src/foo_bar.cc</b>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>C++ Streams</h2>

            <aside class="notes">
              Now comes one of my recent obsessions. :) The C++ Stream API.
            </aside>
          </section>

          <section>
            <p>Renovation through making stuff public</p>

            <p class="fragment">We did it for <b>ObjectWrap</b></p>
            <p class="fragment">We should do it for <b>StreamWrap</b></p>

            <aside class="notes">
              It is a established fact for me that exposing the building blocks
              of APIs helps to renovate, reshape and make them better *a lot*.
              One of such thing that I was always keen to re-do was a
              `StreamWrap` instance.
            </aside>
          </section>

          <section>
            <p><b>StreamWrap</b> wasn't that bad in <b>v0.10</b></p>

            <p class="fragment">Was modified a lot for <b>v0.12</b></p>

            <p class="fragment">Because we needed <b>TLS</b> streams in C++</p>

            <p class="fragment">Looks terrible in <b>v0.12</b></p>

            <aside class="notes">
              It was ok-ish in v0.10, but when we moved TLS (SSL) implementation
              into the C++ land - it has changed dramatically... and, honestly
              saying, not in a good way.
            </aside>
          </section>

          <section>
            <h2>StreamWrap</h2>

            <ul>
              <li class="fragment">
                Support 1-depth nesting<br/>
                via callbacks instances
              </li>
              <li class="fragment">May skip JS callbacks</li>
              <li class="fragment">Does some black magic inside</li>
              <li class="fragment"><b>Performance is fantastic!</b></li>
              <li class="fragment">Source is <u>rigid</u></li>
            </ul>

            <aside class="notes">
              Previously singular `StreamWrap` instance, now became a monster
              that was capable of passing the incoming data elsewhere, skipping
              the JavaScript callbacks completely and doing some dark-magic
              OpenSSL machinery on top of it. The implementation worked like a
              charm, providing much better TLS performance, but the source code
              became cluttered and rigid.
            </aside>
          </section>

          <section>
            <p>But JS streams works so well...</p>
            <p class="fragment">They support multi-level piping</p>
            <p class="fragment">and are transparent to the user!</p>
            <p class="fragment">What if...</p>

            <aside class="notes">
              This "move-parsing-to-elsewhere" thing reminded me a lot about
              that `stream.pipe` that we had in JavaScript streams for ages.
              The natural thing to do about it was to introduce something
              similar in the C++ land too.
            </aside>
          </section>

          <section>
            <p><b>StreamBase</b> in io.js</p>
            <p>To the Rescue!</p>

            <aside class="notes">
              This is exactly what was done in io.js, and the results of this
              live in `src/stream_base.cc`.
            </aside>
          </section>

          <section>
            <p><b>StreamBase</b> (previosuly <b>StreamWrap</b>)</p>
            <ul>
              <li class="fragment">No spooky <b>callbacks</b> instances</li>
              <li class="fragment">Multi-level stream consumption</li>
              <li class="fragment">Almost no black magic</li>
              <li class="fragment">Performance is the same!</li>
            </ul>
          </section>

          <section>
            <p>Still needs to be done:</p>
            <ul>
              <li class="fragment">Way to unconsume/unpipe</li>
              <li class="fragment">Clean-up the APIs</li>
            </ul>
          </section>

          <section>
            <h3>Let's make it public!</h3>

            <p class="fragment">Because:</p>
            <ul>
              <li class="fragment">It is cool</li>
              <li class="fragment">Great performance</li>
              <li class="fragment">HTTP2</li>
              <li class="fragment">Users know better</li>
            </ul>

            <aside class="notes">
              Now we have very general implementation of this thing that could
              be reused in many places. The first thing that I expect will be
              using this, might be an HTTP2 stream. To do it in core, we should
              do it in user-land first, and it could be accomplished only by
              exposing the C++ Stream API, in the same way as we did it with
              ObjectWrap.
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Homework</h2>

            <ol>
              <li class="fragment">Clone the <b>io.js</b> repo</li>
              <li class="fragment">Open <b>src/</b></li>
              <li class="fragment">Go through files</li>
              <li class="fragment">Check what you learned</li>
              <li class="fragment">Fix if we are wrong</li>
              <li class="fragment">Send a PR</li>
              <li class="fragment">...have fun?</li>
            </ol>
          </section>
        </section>

        <section>
          <h2>Thank you!</h2>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'concave', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
